#!/usr/bin/python3

import sys
from os.path import dirname, abspath, exists
from os.path import join as join_path
from prompt_toolkit import prompt
from prompt_toolkit.completion import WordCompleter
from prompt_toolkit.validation import Validator, ValidationError

try:
    from git import Repo
except ImportError:
    print('[FAILURE]: gitpython not installed. pip install gitpython')
    exit(1)

config = {
    'relative_path_authors_file': '../authors.txt',
    'domain': 'superhero.universe',
    'issue_url_base': 'https://superhero-jira.net/',
    'use_issue_in_msg': True
}


class AuthorValidator(Validator):
    def __init__(self, author_suggestions):
        self.author_suggestions = author_suggestions

    def validate(self, document):
        authors = [x.strip().upper() for x in document.text.split(',')]
        valid_authors = self.author_suggestions.keys()
        invalid_authors = list(filter(lambda x: x not in valid_authors, authors))
        if invalid_authors and invalid_authors[0] != '':
            raise ValidationError(message='[ERROR]: Invalid authors - {}'.format(invalid_authors))


class AuthorPrompter(object):
    def __init__(self, authors_file):
        self.authors_dict = self.read_authors_file(authors_file)
        first_name_dict = self.map_first_name_to_details(self.authors_dict)
        self.authors_dict.update(first_name_dict)
        self.suggestions = self.populate_prompter()

    def read_authors_file(self, authors_file):
        try:
            if not exists(authors_file):  raise IOError
            contents = open(authors_file, 'r').readlines()
            authors = [x.split(':') for x in contents]
            return dict(authors)
        except IOError:
            print('[ERROR]: authors.txt not found, check README!')
            sys.exit(1)

    def map_first_name_to_details(self, authors_dict):
        first_names = [v.split(' ')[1].upper() for v in authors_dict.values()]
        return dict(zip(first_names, authors_dict.values()))

    def populate_prompter(self):
        full_author_names = [v.split(',')[0] for v in self.authors_dict.values()]
        meta_dict = dict(zip(self.authors_dict.keys(), full_author_names))
        return WordCompleter(self.authors_dict.keys(), ignore_case=True, match_middle=True, meta_dict=meta_dict)


class CommitMsg(object):
    def __init__(self, authors_dict, coauthors):
        githooks_dir = dirname(abspath(__file__))
        self.repo = Repo(CommitMsg.hook_git_path(githooks_dir))
        self.authors_dict = authors_dict
        self._coauthors = CommitMsg.non_empty_coauthors_list(coauthors)
        self.no_coauthors = not self._coauthors
        self._issue_number = self.parse_issue_number_from_branch() if config['use_issue_in_msg'] else ""

    @staticmethod
    def hook_git_path(hookdir_path):
        # assumes a single .git in path
        split_path_git = hookdir_path.split('.git')
        base_path = split_path_git[0]
        # check if hook is in a submodule
        if split_path_git[1]:
            submodule_name = split_path_git[1].split('/')
            base_path = join_path(base_path, submodule_name[-2])
        return base_path

    def parse_issue_number_from_branch(self):
        if self.repo.head.is_detached:  return ''
        issue_number = CommitMsg.is_issue_number_in_branch(self.repo.active_branch.name)
        # if isse number is part of the branch name
        if issue_number is None:
            issue_number = str(input('[INPUT]: Enter issue number (optional): '))

        return issue_number

    @staticmethod
    def is_issue_number_in_branch(active_branch):
        # check if branch ends with "_issuexxxxx" where xxxxx is the issue number
        issue_number = active_branch.lower().split('_')[-1]
        return issue_number[2:] if 'issue' in issue_number else None

    @property
    def issue_number(self):
        if self._issue_number:
            issue_url = config['issue_url_base'] + self._issue_number
            self._issue_number = '\nItem: {}\n{}\n'.format(self._issue_number, issue_url)

        return self._issue_number

    @staticmethod
    def non_empty_coauthors_list(coauthors):
        valid_coauths = [x.strip().upper() for x in coauthors.split(',')]
        return list(filter(lambda x: x, valid_coauths))

    def get_coauthor_name_email(self):
        return [self.authors_dict[x.strip().upper()].split(',') for x in self._coauthors]

    @property
    def co_authors(self):
        if self.no_coauthors:
            return '\n'
        else:
            prefix_str = 'Co-authored-by: {}'
            _coauth_fmt = lambda x: '{} <{}@{}>'.format(x[0].strip(), x[1].strip(), config['domain'])

            coauths_lst = self.get_coauthor_name_email()
            coauths_str = [prefix_str.format(_coauth_fmt(x)) for x in coauths_lst]
            # git expects co-authors after two blank lines
            return '\n\n' + '\n'.join(coauths_str) + '\n\n'


def input_coauthor_initials():
    author_prompter = AuthorPrompter(config['relative_path_authors_file'])
    author_validator = AuthorValidator(author_prompter.authors_dict)
    print(
        """\n[INFO]: ADD co-authors (if any) as a comma separated list of either 2 letter initials or first names. 
        Auto-suggest feature lists the authors in the database (indexed by both initials and first name), and 
        auto-complete can be used with TAB. Hit ENTER only when you are done adding the coauthors, for selecting the
        co-author use TAB or arrow keys (instead of ENTER).
        example input - TS, CLARK(for Tony Stark and Clark Kent )
        Open ../authors.txt to view the current list of authors for this project.\n""")
    coauthors = prompt('[INPUT]: Enter co-author(s) -',
                       completer=author_prompter, complete_while_typing=True,
                       validator=author_validator, validate_while_typing=False
                       )
    return author_prompter.authors_dict, coauthors


def prepare_message(commit_msg_filepath, authors_dict, auths):
    """
    prepares the message in the format:

    commit summary

    <optional body>
    Issue: xxxxx
    <issue_url>/xxxxx


    Co-authored-by: A B <A.B@company.domain>

    # comments
    """
    commit_msg = CommitMsg(authors_dict, auths)

    with open(commit_msg_filepath, 'r+') as f:
        msg = f.readlines()
        f.seek(0, 0)
        # first line of variable msg is already filled if git commit -m "<msg>" is executed
        f.write("{}{}{}{}".format(msg[0], commit_msg.issue_number, commit_msg.co_authors, ''.join(msg[1:])))


if __name__ == '__main__':
    commit_msg_filepath = sys.argv[1]
    commit_type = sys.argv[2] if len(sys.argv) > 2 else ''

    # execute only for message commit type. For amend, merge, squash simply exit
    if commit_type not in ['', 'message']:
        sys.exit(0)

    authors_dict, coauthors = input_coauthor_initials()
    prepare_message(commit_msg_filepath, authors_dict, coauthors)
