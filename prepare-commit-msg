#!/usr/bin/env python3

import sys
from os.path import dirname, abspath, exists
from os.path import join as join_path
from utils import read_authors_file_as_dict, config
from coauthors_commit_msg import CoauthorsCommitMsg
from git import Repo


class CommitMsg(object):
    def __init__(self, config):
        githooks_dir = dirname(abspath(__file__))
        self.repo = Repo(CommitMsg.hook_git_path(githooks_dir))
        self._config_coauthors = config['coauthors']
        self._config_issue = config['issue']
        self.coauthors_msg = self._issue_number = ""

    def fill_issue_number(self):
        self._issue_number = self.parse_issue_number_from_branch() if self._config_issue['use_issue_in_msg'] else ""

    def fill_coauthors(self):
        git_coco_msg_file = self._config_coauthors['coauthors_git_msg_file']
        self.coauthors_msg = self.read_authors_msg_autosuggest(git_coco_msg_file) if exists(
            git_coco_msg_file) else self.read_authors_msg_eidetic(self._config_coauthors['authors_file'])

    @staticmethod
    def hook_git_path(hookdir_path):
        # assumes a single .git in path
        split_path_git = hookdir_path.split('.git')
        base_path = split_path_git[0]
        # check if hook is in a submodule
        if split_path_git[1]:
            submodule_name = split_path_git[1].split('/')
            base_path = join_path(base_path, submodule_name[-2])
        return base_path

    def parse_issue_number_from_branch(self):
        if self.repo.head.is_detached:  return ''
        issue_number = CommitMsg.is_issue_number_in_branch(self.repo.active_branch.name)
        # if issue number is part of the branch name
        if issue_number is None:
            sys.stdin = open('/dev/tty', 'r')
            issue_number = str(input('[INPUT]: Enter issue number (optional): '))

        return issue_number

    @staticmethod
    def is_issue_number_in_branch(active_branch):
        # check if branch ends with "_issuexxxxx" where xxxxx is the issue number
        issue_number = active_branch.lower().split('_')[-1]
        return issue_number[2:] if 'issue' in issue_number else None

    @property
    def issue_number(self):
        if self._issue_number:
            issue_url = self._config_issue['issue_url_base'] + self._issue_number
            self._issue_number = '\nItem: {}\n{}\n'.format(self._issue_number, issue_url)

        return self._issue_number

    def input_coauthor_initials(self):
        sys.stdin = open('/dev/tty', 'r')
        coauthors = input(
            """\n[INFO]: ADD co-authors (if any) as a comma separated list of 2 letter initials.
            example input - ts, ck (for Tony Stark and Clark Kent )
            Open ../authors.txt to view the current list of authors for this project.
            \n[INPUT]: Enter co-author(s) initials: """)
        return coauthors

    def read_authors_msg_eidetic(self, authors_file):
        coauths_csv = self.input_coauthor_initials()
        authors_dict = read_authors_file_as_dict(authors_file)
        coco_msg = CoauthorsCommitMsg(coauths_csv, authors_dict, self._config_coauthors)
        return coco_msg.co_authors

    def read_authors_msg_autosuggest(self, git_coco_msg_file):
        with open(git_coco_msg_file) as f:
            coauths_msg = f.read()
        return coauths_msg


def prepare_message(commit_msg_filepath, config):
    """
    prepares the message in the format:

    commit summary

    <optional body>
    Issue: xxxxx
    <issue_url>/xxxxx


    Co-authored-by: A B <A.B@company.domain>

    # comments
    """
    commit_msg = CommitMsg(config)
    commit_msg.fill_coauthors()
    commit_msg.fill_issue_number()

    with open(commit_msg_filepath, 'r+') as f:
        msg = f.readlines()
        f.seek(0, 0)
        # first line of variable msg is already filled if git commit -m "<msg>" is executed
        f.write("{}{}{}{}".format(msg[0], commit_msg.issue_number, commit_msg.coauthors_msg, ''.join(msg[1:])))


if __name__ == '__main__':
    commit_msg_filepath = sys.argv[1]
    commit_type = sys.argv[2] if len(sys.argv) > 2 else ''

    # execute only for message commit type. For amend, merge, squash simply exit
    if commit_type not in ['', 'message']:
        sys.exit(0)

    prepare_message(commit_msg_filepath, config)
